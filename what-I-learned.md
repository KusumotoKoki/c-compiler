# What I Learned

## Chap01: [はじめに](https://www.sigbus.info/compilerbook#%E3%81%AF%E3%81%98%E3%82%81%E3%81%AB)

## Chap02: [機械語とアセンブラ](https://www.sigbus.info/compilerbook#%E6%A9%9F%E6%A2%B0%E8%AA%9E%E3%81%A8%E3%82%A2%E3%82%BB%E3%83%B3%E3%83%96%E3%83%A9)

### CPU とメモリ

> CPU が実行するプログラムと、そのプログラムが読み書きするデータは、どちらもメモリに入っています。CPU は「現在実行中の命令のアドレス」を CPU 内部に保持していて、そのアドレスから命令を読み出して、そこに書かれていることを行い、そして次の命令を読み出して実行する、ということを行なっています。その現在実行中の命令のアドレスのことを「プログラムカウンタ」（PC）や「インストラクションポインタ」（IP）といいます。CPU が実行するプログラムの形式そのもののことを「機械語」(machine code) といいます。

> 特定の機械語の命令を総称として「命令セットアーキテクチャ」（instruction set architecture, ISA）あるいは「命令セット」といいます。

### 命令セットアーキテクチャ

- x86-64
	- 別名: AMD64, Intel 64, x64
	- 64bit
- x86
	- 32bit
- ARM64
	- 別名: AArch64
	- 64bit
- 32bit の ARM アーキテクチャもある

- Linux は，複数の CPU アーキテクチャをサポートしてる
- macOS (Intel) は x86-64 で macOS (M1, M2) は ARM64

### アセンブラ

> アセンブリは機械語にほぼそのまま 1 対 1 で対応するような言語なのですが、機械語よりもはるかに人間にとって読みやすいものになっています。

- アセンブリを機械語に変換するやつが「アセンブラ」

- 実際に，`$ objdump -d -M intel /bin/ls` でアセンブリが見れる
	- `objdump`: 機械語をアセンブリに逆アセンブルする
	- `/bin/ls`: 機械語で書かれているバイナリファイル
	- `-d`: 逆アセンブル（disassemble）をする
	- `-M intel`: Intel 構文で

### C とそれに対応するアセンブラ

C プログラムの例
```test1.c
int main() {
  return 42;
}
```

これに対応するアセンブリプログラムを直接書いて `test2.s` という名前で保存する．
```test2.s
.intel_syntax noprefix
.globl main
main:
        mov rax, 42
        ret
```

次で実際にコンパイルできる．
```bash
$ cc -o test2 test2.s
```

> 整数を入れられるレジスタは RAX を含めて合計で 16 個あるのですが、関数からリターンしたときに RAX に入っている値が関数の返り値という約束になっている

> 大雑把にいうと、C コンパイラは、`test1.c` のような C コードを読み込んだ時に、`test2.s` のようなアセンブリを出力するプログラムということになります。

### 関数呼び出しを含む例

```test3.s
.intel_syntax noprefix
.globl plus, main

plus:
        add rsi, rdi
        mov rax, rsi
        ret

main:
        mov rdi, 3
        mov rsi, 4
        call plus
        ret
```

> 1 行目はアセンブリの文法を指定する命令です。
> 2 行目の `.globl` から始まる行は、`plus` と `main` という 2 つの関数がファイルスコープではなくプログラム全体から見える関数だということをアセンブリに指示しています。

> `add` は足し算を行う命令です。この場合には、RSI レジスタと RDI レジスタを足した結果が RSI レジスタに書き込まれます。

> `mov` は move の省略形ですが、実際にはデータを移動するわけではなく単にコピーする命令です。

- `call` と `ret` はセット
	- `call`: 関数を呼び出す命令
		- `call` の次の命令（この場合 `ret`）のアドレスをスタックにプッシュ
		- `call` の引数として与えられたアドレスにジャンプ
	- `ret`: 呼び出し元の関数の実行を再開する命令
		- スタックからアドレスを 1 つポップ
		- そのアドレスにジャンプ

### オンライン・コンパイラ
- [Compiler Explorer](https://godbolt.org/)
> Compiler Explorer で画面の左半分のテキストボックスにコードを入力すると、右半分にそれに対応するアセンブリ出力がリアルタイムに表示されます。C コードがどのようなアセンブリに変換されるのか確認したいときはこのサイトを使うのがよいでしょう。


## Chap03: [電卓レベルの言語の作成](https://www.sigbus.info/compilerbook#%E9%9B%BB%E5%8D%93%E3%83%AC%E3%83%99%E3%83%AB%E3%81%AE%E8%A8%80%E8%AA%9E%E3%81%AE%E4%BD%9C%E6%88%90)

### [ステップ1：整数1個をコンパイルする言語の作成](https://www.sigbus.info/compilerbook#%E3%82%B9%E3%83%86%E3%83%83%E3%83%971%E6%95%B4%E6%95%B01%E5%80%8B%E3%82%92%E3%82%B3%E3%83%B3%E3%83%91%E3%82%A4%E3%83%AB%E3%81%99%E3%82%8B%E8%A8%80%E8%AA%9E%E3%81%AE%E4%BD%9C%E6%88%90)
- `lagucc` という名前でコンパイラプログラムをつくることにした
- `lagucc/` 以下に次をつくる
	- `lagucc.c`
		- アセンブリを出力する
		- これから成長させる
	- `test.sh`
		- テストをする
	- `Makefile`
		- `$ make` で `lagucc` の生成が，`$ make test` でテストができるようになる
	- `.gitignore`
- それぞれのファイルの具体的な実装は Compiler Book を参照のこと

### [ステップ2：加減算のできるコンパイラの作成](https://www.sigbus.info/compilerbook#%E3%82%B9%E3%83%86%E3%83%83%E3%83%972%E5%8A%A0%E6%B8%9B%E7%AE%97%E3%81%AE%E3%81%A7%E3%81%8D%E3%82%8B%E3%82%B3%E3%83%B3%E3%83%91%E3%82%A4%E3%83%A9%E3%81%AE%E4%BD%9C%E6%88%90)

- `strtol(str, &endptr, 10)`
	- `str`が指す文字列を，
	- `10`進数として先頭から解釈していって，
	- `long`型の数に変換する
	- どこまで解釈できたかは，`&endptr`に返ってくる
	- ぜんぶ解釈できたら，`*endptr == '\0'`なはず
-

